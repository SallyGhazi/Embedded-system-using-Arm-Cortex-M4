/*
* Inter-Integreated Circuit 
* I2C
* Two Wire Interface[SDA-SCL]
* TWI
*/
// SCL [serial clock] >> for synchronizing data transfer between the master and the slave.
//SDA [serial data] >> the data line.

/*
operation modes
1- Master Transmitter 
2- Master  Receiver
3- Slave Transmitter 
4- Slave  Receiver
*/

/*
 * Transmitter >>     the device which sends data to the Bus.
 * Receiver >>        the device which receives data from the Bus.
 * Master >>          the device which initiates a transfer, generates clock signals and terminates a transfer.
 * Slave >>           the device addressed by a master.
 * Multi-master >>    more than one master can attempt to control the bus at the same time without corrupting the message.
 * Arbitration >>     procedure to ensure that, if more than one master simultaneously tries to control the bus, only one is allowed to do so and the winning message is not corrupted.
 * Synchronization >> procedure to synchronize the clock signals of two or more devices.

*/

// Transactions are initiated and completed by the master.
// ALL messages have an address frame and data frame.
// Data is placed on the SDA line after SCL goes low, and it is sampled after the SCL line goes high.
//
 

/*
    _________________________________________________________________________
   | start | slave    address       |R/W|ACK|      DATA (n-bytes) |ACK|STOP |
   |_______|________________________|___|___|_____________________|___|_____|
   
(1)The Protocol - START an STOP

[#] All transactions begin with START and are terminated by STOP.
[#] A HIGH to LOW transition on the SDA line while SCL is HIGH defines a START condition.
[#] A LOW to HIGH transition on the SDA line while SCL is HIGH defines a STOP condition.
[#] START and STOP conditions are always generated by the master. 
[#] The bus is considered to be free again a certain time after the STOP condition.
[#] The bus stays busy if a repeated START is generated instead of a STOP condition.

(2)The Protocol - BYTE Format

[#] Any information transmitted on the SDA line must be eight bits long.
[#] The number of bytes that can be transmitted per transfer is unrestricted.
[#] Each byte must be followed by an Acknowledge (ACK) bit. 
[#] Data is transferred with the Most Significant Bit (MSB) first.

(3)The Protocol - Address Frame

[#] The address frame is first in any new communication sequence.
[#] For a 7-bit address, the address is sent out significant bit (MSB) first,
    followed by a R/W bit indicating whether this is a read (1) or write (0) operation.
	
	
(4) The Protocol - Data Frame
 
[#] The data frame begins transmission after the address frame is sent.
[#] The master will simply continue generating clock pulses on SCL at a regular interval,
    and the data will be placed on SDA by either the master or the slave,
	depending on whether the R/W bit indicated a read or write operation.
*/

//===============================================

//12C Clock Speed
/* 
 - This is the speed of the 12C interface and should correspond with the bus speeds defined in the 12C specification.
 
 The specification defines the following modes:

[#] Standard-mode    : 100 KHz max
[#] Fast-mode        : 400 KHz max
[#] Fast-mode Plus   : 1 MHz
[#] High-speed mode  : 3.4 MHz

*/
//===============================================
//12C Duty Cycle
/*
[#] Specifies the ratio between tow and tHIGH of the I2C SCL line.
[#] Possible values:
                   I2C_DUTYCYCLE_2    = 2:1
                   I2C_DUTYCYCLE_16_9 = 16:9
 
[#] By choosing the appropriate duty cycle we can pre-scale the peripheral clock to achieve the desired 12C speed.

*/
//===============================================
//Difference between 12C and SPI
/*
[#] 12C is half duplex communication and SPI is full duplex communication.
[#] 12C supports multi master and multi slave and SPI supports single master.
[#] 12C is a two wire protocol and SPI is a four wire protocol. 
[#] 12C supports clock stretching and SPI does not have clock stretching.
[#] 12C is slower than SPI.SPI Max speed is FPclk/2. In STM Microcontrollers max seed is just 400 KHz. 
    Data rate from sender to receiver in 1 Sec is very much lesser in 12C compared to SPI.
[#] 12C has extra overhead start and stop bits and SPI does not have any start and stop bits.
[#] 12C has an acknowledgment bit after every byte of transfer.
[#] 12C has a pullup resistor requirement.

*/
//===============================================
//Procedure if Master Wants to Access Slave
/*
(1) Suppose a master wants to send data to a slave:
[#]  Master-transmitter sends a START condition and addresses the slave-receiver.
[#]  Master-transmitter sends data to slave-receiver.
[#]  Master-transmitter terminates the transfer with a STOP condition.


(2) If a master wants to receive/read data from a slave:
[#]  Master-receiver sends a START condition and addresses the slave-transmitter.
[#]  Master-receiver sends the requested register to read to slave-transmitter.
[#]  Master-receiver receives data from the slave-transmitter.
[#]  Master-receiver terminates the transfer with a STOP condition.
*/

 
/*

Example

In SM Mode,generate a100 Khz SCL Frequency APB1 Clock(PCLK1)=16 Mhz

1) Configure the mode in CCR Register (15th bit)

2) Program FREQ Field of CR2 with the value of PCLK1

3)Calculate and Program CCR Value in CCR field of CCR Register


*/
/*
========  12C Init    =======
[1] Enable the clock access to PORT B-12C1.
[2] SET PB7 AND PB8 to alternate function.
[3] SET OUTPUTTYPE as OPEN DRAIN.
[4] SET Internal PULLUP FOR BOTH.
[5] SET THE ALTERNATE FUNCTION TYPE FOR 12C.
[6] ENTER TO RESET MODE.
[7] COME OUR OF THE RESET MODE.
[8] Set the Peripheral Clock Frequency(16 mhz).
[9] Set the Standard Mode (I2C_100KHZ).
*/


/*
steps for I2C iNIT
1- Configure the Mode (Standard or Fast).
2- Configure the speed of the serial clock [SCL]
3- Configure the device address (Applicable when Devices is slave)
4- Enable the Acking
5- Configure The RISE Time for I2C Pins.
All the above configuration must be done when the peripheral is disabled in the control register

*/

/* I2C ByteRead*/
/*
[1] Wait Until Bus is not Busy.
[2] Generate Start Condition.
[3] Wait Until The Start Flag is Set.
[4] Transmit Slave Address + Write.
[5] Wait Until The Address Flag is Set.
[6] Clear The Address Flag.
[7] Send Memory Address. 
[8] Wait Until The Transmitter is Empty.
[9] Generate Restart.
[10] Wait Until The Start Flag is Set.
[11] Transmit Slave Address + Write.
[12] Wait Until The Address Flag is Set.
[13] Disable Acknowledgement.
[14] Clear The Address Flag.
[15] Generate Stop.
[16] Wait Until RXNE Flag is Set.
[17] Read Data from Data Register.
*/

/* I2C BurstRead*/
/*
[1] Wait Until Bus is not Busy.
[2] Generate Start Condition.
[3] Wait Until The Start Flag is Set.
[4] Transmit Slave Address + Write.
[5] Wait Until The Address Flag is Set.
[6] Clear The Address Flag. 
[7] Wait Until The Transmitter is Empty.
[8] Send Memory Address.
[9] Generate Restart.
[10] Wait Until The Start Flag is Set.
[11] Transmit Slave Address + Write.
[12] Wait Until The Address Flag is Set.
[13] Clear The Address Flag.
[14] Enable Acknowledgement.
while(n>0U)
{
	if(n == 1U)
	{
		//Generate Stop.
		//Wait Until RXNE Flag is Set.
		// Read Data from Data Register.
		break;		
	}
	else
	{
		//Wait Until RXNE Flag is Set.
		// Read Data from Data Register.
		n--;
		
	}
}
*/


/* I2C1_BurstWrite*/
/*
{
	//[1] Wait Until Bus is not Busy.
	//[2] Generate Start Condition.
	//[3] Wait Until The Start Flag is Set.
	//[4] Transmit Slave Address + Write.
	//[5] Wait Until The Address Flag is Set.
	//[6] Clear The Address Flag.
	//[7] Send Memory Address.
	//[8] Wait Until The Transmitter is Empty.
	//[9] Send Memory Address.

	for(int i=0;i<n;i++)
	{
		//[10] Wait Until The Transmitter is Empty.
	}
	//[11] Generate Stop after Data Received.

}
*/